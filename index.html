<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Medal of Honor PS1-Style Demo - Level 1: Bunker mit Texturen</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: monospace; color: white; background: black; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 10px; left: 10px; z-index: 100;
            font-size: 20px; text-shadow: 2px 2px 4px black;
        }
        #instructions {
            position: absolute; bottom: 10px; left: 10px; z-index: 100;
            font-size: 14px; text-shadow: 1px 1px 2px black;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="ui">
        <div>Kills: <span id="score">0</span>/10</div>
        <div>Level: Bunker Breach</div>
    </div>
    <div id="instructions">
        WASD: Bewegen | Maus: Schauen | Space: Springen | Klick: Schießen<br>
        Klicke zum Starten (Maus-Sperre)
    </div>
    <script>
        // Szene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Heller Himmel
        scene.fog = new THREE.Fog(0x808080, 5, 80); // PS1-Nebel

        // Kamera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 12); // Start außerhalb

        // Renderer (retro low-res)
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(1);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.BasicShadowMap; // Low-poly Schatten
        document.body.appendChild(renderer.domElement);

        // Clock für Delta-Time
        const clock = new THREE.Clock();

        // Lichter
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // Texture Loader
        const loader = new THREE.TextureLoader();

        // Texturen laden (LOCAL: Lade runter und packe in /textures/ !)
        // Download-Links (CC0 free):
        // ground.png: https://dl.polyhaven.com/file/ph-assets/Textures/png/1k/sand_01/sand_01_diff_1k.png
        // wall.png: https://ambientcg.com/get?file=BrickWall025_1K_Color.png
        // enemy.png: https://ambientcg.com/get?file=Fabric028_1K_Color.png
        // ALTERNATIVE: Direkte URLs (könnte CORS haben):
        // const groundTexture = loader.load('https://dl.polyhaven.com/file/ph-assets/Textures/png/1k/sand_01/sand_01_diff_1k.png');
        const groundTexture = loader.load('textures/ground.png');
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(20, 20);
        groundTexture.encoding = THREE.sRGBEncoding;

        const wallTexture = loader.load('textures/wall.png');
        wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
        wallTexture.repeat.set(2, 2);

        const enemyTexture = loader.load('textures/enemy.png');
        enemyTexture.wrapS = enemyTexture.wrapT = THREE.RepeatWrapping;
        enemyTexture.repeat.set(1, 2);

        // Materialien
        const groundMaterial = new THREE.MeshLambertMaterial({ map: groundTexture });
        const wallMaterial = new THREE.MeshLambertMaterial({ map: wallTexture });
        const enemyMaterial = new THREE.MeshLambertMaterial({ map: enemyTexture });

        // LEVEL DESIGN: Bunker (Raum mit Wänden)
        const groundGeometry = new THREE.PlaneGeometry(60, 60);
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Wände (Bunker-Wände)
        const walls = [];
        const wallGeometries = {
            long: new THREE.BoxGeometry(30, 6, 1),
            short: new THREE.BoxGeometry(1, 6, 20),
            sandbag: new THREE.BoxGeometry(4, 1.5, 2)
        };
        const wallPositions = [
            // Außenwände
            { geo: 'long', pos: new THREE.Vector3(0, 3, -20), rot: 0 }, // Hintere Wand
            { geo: 'long', pos: new THREE.Vector3(0, 3, 20), rot: 0 },  // Vordere (offen?)
            { geo: 'short', pos: new THREE.Vector3(-15, 3, 0), rot: Math.PI / 2 },
            { geo: 'short', pos: new THREE.Vector3(15, 3, 0), rot: Math.PI / 2 },
            // Innere Barrikaden/Sandbags
            { geo: 'sandbag', pos: new THREE.Vector3(-8, 0.75, -10), rot: 0 },
            { geo: 'sandbag', pos: new THREE.Vector3(8, 0.75, -10), rot: 0 },
            { geo: 'sandbag', pos: new THREE.Vector3(0, 0.75, 5), rot: Math.PI / 4 }
        ];

        wallPositions.forEach(wp => {
            const geometry = wallGeometries[wp.geo].clone();
            const wall = new THREE.Mesh(geometry, wallMaterial);
            wall.position.copy(wp.pos);
            wall.rotation.y = wp.rot;
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
            walls.push(wall);
            geometry.computeBoundingBox();
        });

        // Kollider (für Physik)
        const colliders = walls.map(w => w); // Alle Wände kollidierbar

        // Gegner (10 rote Boxen mit Camo-Texture)
        const enemies = [];
        const enemyGeometry = new THREE.BoxGeometry(1, 2, 0.8);
        enemyGeometry.computeBoundingBox();
        for (let i = 0; i < 10; i++) {
            const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            enemy.position.set(
                (Math.random() - 0.5) * 30,
                1,
                (Math.random() - 0.5) * 30 - 5 // Im Bunker-Bereich
            );
            enemy.castShadow = true;
            scene.add(enemy);
            enemies.push(enemy);
        }

        // Waffe (verbessert)
        const gunGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8);
        const gunMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
        const gun = new THREE.Mesh(gunGeometry, gunMaterial);
        gun.rotation.z = Math.PI / 2;
        gun.position.set(0.4, -0.4, -0.7);
        camera.add(gun);
        scene.add(camera);

        // Physik-Variablen
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const speed = 20; // Units per second
        let isJumping = false;
        const gravity = 30;
        const playerRadius = 0.6;
        const playerHeight = 1.8;

        // Steuerung
        const keys = {};
        document.addEventListener('keydown', (e) => { keys[e.code] = true; });
        document.addEventListener('keyup', (e) => { keys[e.code] = false; });

        // Pointer Lock
        document.addEventListener('click', () => renderer.domElement.requestPointerLock());
        let euler = new THREE.Euler(0, 0, 0, 'YXZ');
        document.addEventListener('mousemove', (event) => {
            if (document.pointerLockElement === renderer.domElement) {
                euler.setFromQuaternion(camera.quaternion);
                euler.y -= event.movementX * 0.002;
                euler.x -= event.movementY * 0.002;
                euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
                camera.quaternion.setFromEuler(euler);
            }
        });

        // Schießen
        let score = 0;
        document.addEventListener('mousedown', (event) => {
            if (event.button === 0 && document.pointerLockElement) {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(), camera);
                const intersects = raycaster.intersectObjects(enemies);
                if (intersects.length > 0) {
                    const hit = intersects[0].object;
                    scene.remove(hit);
                    enemies.splice(enemies.indexOf(hit), 1);
                    score++;
                    document.getElementById('score').textContent = score;
                    console.log('Hit! Kills:', score);
                    if (score >= 10) alert('Level Cleared! Bunker gesichert.');
                }
            }
        });

        // Kollisions-Check
        function checkCollision(newPos) {
            const playerBox = new THREE.Box3().setFromCenterAndSize(newPos, new THREE.Vector3(playerRadius*2, playerHeight, playerRadius*2));
            for (let collider of colliders) {
                const colliderBox = collider.geometry.boundingBox.clone();
                colliderBox.applyMatrix4(collider.matrixWorld);
                if (playerBox.intersectsBox(colliderBox)) return false;
            }
            return true;
        }

        // Animate Loop
        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(0.05, clock.getDelta()); // Cap delta

            // Bewegung
            velocity.x = 0;
            velocity.z = 0;
            direction.z = Number(keys['KeyW']) - Number(keys['KeyS']);
            direction.x = Number(keys['KeyD']) - Number(keys['KeyA']);
            direction.normalize();
            if (direction.length() > 0) {
                const moveDir = new THREE.Vector3();
                camera.getWorldDirection(moveDir);
                moveDir.y = 0;
                moveDir.normalize();
                const right = new THREE.Vector3();
                right.crossVectors(moveDir, new THREE.Vector3(0,1,0)).normalize();
                velocity.addScaledVector(moveDir, direction.z * speed * delta);
                velocity.addScaledVector(right, direction.x * speed * delta);
            }

            // Jump & Gravity
            if (keys['Space'] && !isJumping) {
                velocity.y = 8 * delta;
                isJumping = true;
            }
            velocity.y -= gravity * delta;
            const newPos = camera.position.clone().addScaledVector(velocity, delta);

            // Y-Kollision (Boden)
            if (newPos.y < 1.6) {
                newPos.y = 1.6;
                velocity.y = 0;
                isJumping = false;
            }

            // XZ-Kollision
            const testPos = newPos.clone();
            testPos.y = 1.6;
            if (checkCollision(testPos)) {
                camera.position.copy(newPos);
            } else {
                // Slide along walls (simple)
                velocity.multiplyScalar(0.7);
            }

            renderer.render(scene, camera);
        }
        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
