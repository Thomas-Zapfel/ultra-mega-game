<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Medal of Honor PS1-Style Demo - Level 1: Bunker mit GLTF-Modellen</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: monospace; color: white; background: black; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 10px; left: 10px; z-index: 100;
            font-size: 20px; text-shadow: 2px 2px 4px black;
        }
        #instructions {
            position: absolute; bottom: 10px; left: 10px; z-index: 100;
            font-size: 14px; text-shadow: 1px 1px 2px black;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 24px; height: 24px; z-index: 100;
            pointer-events: none;
            color: lime; font-size: 24px; line-height: 24px; text-align: center;
            text-shadow: 0 0 5px lime;
            font-weight: bold;
        }
        #crosshair::before { content: '+'; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 200; font-size: 24px; color: lime;
        }
    </style>
    <!-- Updated to Three.js r182 (latest 2026) -->
   <!-- 1. Three.js Core laden -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.min.js"></script>

    <!-- 2. Addons / Loaders (nach Core!) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/loaders/GLTFLoader.js"></script>
</head>
<body>
    <div id="loading">Lade Soldaten-Modelle... (klicke zum Starten)</div>
    <div id="crosshair"></div>
    <div id="ui">
        <div>Kills: <span id="score">0</span>/10</div>
        <div>Level: Bunker Breach</div>
    </div>
    <div id="instructions">
        WASD: Bewegen | Maus: Schauen | Space: Springen | Klick: Schie√üen (Kugeln!)<br>
        Ziel: 10 Nazis eliminieren!
    </div>
    <script>
        // Szene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x808080, 5, 80);

        // Kamera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 12);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(1);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.BasicShadowMap;
        document.body.appendChild(renderer.domElement);

        // Clock
        const clock = new THREE.Clock();

        // Lichter
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 100;
        scene.add(dirLight);

        // Texturen (f√ºr Level)
        const textureLoader = new THREE.TextureLoader();
        const groundTexture = textureLoader.load('textures/ground.png');
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(20, 20);
        groundTexture.encoding = THREE.sRGBEncoding;
        const wallTexture = textureLoader.load('textures/wall.png');
        wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
        wallTexture.repeat.set(2, 2);

        const groundMaterial = new THREE.MeshLambertMaterial({ map: groundTexture });
        const wallMaterial = new THREE.MeshLambertMaterial({ map: wallTexture });

        // LEVEL (Bunker)
        const groundGeometry = new THREE.PlaneGeometry(60, 60);
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const walls = [];
        const wallGeometries = {
            long: new THREE.BoxGeometry(30, 6, 1),
            short: new THREE.BoxGeometry(1, 6, 20),
            sandbag: new THREE.BoxGeometry(4, 1.5, 2)
        };
        const wallPositions = [
            { geo: 'long', pos: new THREE.Vector3(0, 3, -20), rot: 0 },
            { geo: 'long', pos: new THREE.Vector3(0, 3, 20), rot: 0 },
            { geo: 'short', pos: new THREE.Vector3(-15, 3, 0), rot: Math.PI / 2 },
            { geo: 'short', pos: new THREE.Vector3(15, 3, 0), rot: Math.PI / 2 },
            { geo: 'sandbag', pos: new THREE.Vector3(-8, 0.75, -10), rot: 0 },
            { geo: 'sandbag', pos: new THREE.Vector3(8, 0.75, -10), rot: 0 },
            { geo: 'sandbag', pos: new THREE.Vector3(0, 0.75, 5), rot: Math.PI / 4 }
        ];

        wallPositions.forEach(wp => {
            const geometry = wallGeometries[wp.geo].clone();
            const wall = new THREE.Mesh(geometry, wallMaterial);
            wall.position.copy(wp.pos);
            wall.rotation.y = wp.rot;
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
            walls.push(wall);
        });
        const colliders = walls;

        // **3D MODELLE: Passe deine Sketchfab-Dateien an!**
        const gltfLoader = new THREE.GLTFLoader();
        let soldierModel;
        const enemies = [];
        let modelsLoaded = false;

        gltfLoader.load(
            'models/soldier/scene.gltf',  // <-- DEIN PFAD: scene.gltf !
            (gltf) => {
                soldierModel = gltf.scene;
                soldierModel.scale.set(2, 2, 2);  // Angepasst f√ºr perfekte Gr√∂√üe
                soldierModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        child.material = new THREE.MeshLambertMaterial({ 
                            map: child.material.map, 
                            color: child.material.color 
                        });  // Retro-Lambert f√ºr PS1-Look
                    }
                });
                soldierModel.updateMatrixWorld(true);

                // 10 Clones
                for (let i = 0; i < 10; i++) {
                    const enemy = soldierModel.clone();
                    enemy.position.set(
                        (Math.random() - 0.5) * 30,
                        0,  // Y=0 f√ºr F√º√üe auf Boden
                        (Math.random() - 0.5) * 30 - 5
                    );
                    enemy.rotation.y = Math.random() * Math.PI * 2;
                    enemy.userData.boundingBox = new THREE.Box3().setFromObject(enemy);
                    scene.add(enemy);
                    enemies.push(enemy);
                }
                modelsLoaded = true;
                document.getElementById('loading').style.display = 'none';
                console.log('‚úÖ 10 Nazi-Soldaten geladen! Schie√ü los!');
            },
            (progress) => {
                console.log('Lade Modell: ', (progress.loaded / progress.total * 100) + '%');
            },
            (error) => {
                console.error('‚ùå Modell-Laden fehlgeschlagen:', error);
                document.getElementById('loading').innerHTML = 'Modell-Fehler! Erstelle Fallback-Boxen...';
                // Fallback: Rote Boxen
                const enemyGeometry = new THREE.BoxGeometry(1, 2, 0.8);
                const enemyMaterial = new THREE.MeshLambertMaterial({ color: 0x8B0000 });
                for (let i = 0; i < 10; i++) {
                    const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
                    enemy.position.set(
                        (Math.random() - 0.5) * 30,
                        1,
                        (Math.random() - 0.5) * 30 - 5
                    );
                    enemy.castShadow = true;
                    scene.add(enemy);
                    enemies.push(enemy);
                }
                modelsLoaded = true;
                document.getElementById('loading').style.display = 'none';
            }
        );

        // Waffe
        const gunGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8);
        const gunMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
        const gun = new THREE.Mesh(gunGeometry, gunMaterial);
        gun.rotation.z = Math.PI / 2;
        gun.position.set(0.4, -0.4, -0.7);
        camera.add(gun);
        scene.add(camera);

        // Physik & Steuerung (wie vorher, schnell!)
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const speed = 50;
        let isJumping = false;
        const gravity = 30;
        const playerRadius = 0.6;
        const playerHeight = 1.8;

        const keys = {};
        document.addEventListener('keydown', (e) => { keys[e.code] = true; });
        document.addEventListener('keyup', (e) => { keys[e.code] = false; });

        document.addEventListener('click', () => {
            if (!modelsLoaded) return;
            renderer.domElement.requestPointerLock();
        });

        let euler = new THREE.Euler(0, 0, 0, 'YXZ');
        document.addEventListener('mousemove', (event) => {
            if (document.pointerLockElement === renderer.domElement) {
                euler.setFromQuaternion(camera.quaternion);
                euler.y -= event.movementX * 0.002;
                euler.x -= event.movementY * 0.002;
                euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
                camera.quaternion.setFromEuler(euler);
            }
        });

        // Kugeln
        const bullets = [];
        const bulletSpeed = 200;
        document.addEventListener('mousedown', (event) => {
            if (event.button === 0 && document.pointerLockElement && modelsLoaded) {
                const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                bullet.position.copy(camera.position);
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(camera.quaternion);
                bullet.userData.velocity = forward.multiplyScalar(bulletSpeed);
                scene.add(bullet);
                bullets.push(bullet);
            }
        });

        let score = 0;
        const scoreEl = document.getElementById('score');

        function checkCollision(newPos) {
            const playerBox = new THREE.Box3().setFromCenterAndSize(newPos, new THREE.Vector3(playerRadius*2, playerHeight, playerRadius*2));
            for (let collider of colliders) {
                const colliderBox = collider.geometry.boundingBox.clone();
                colliderBox.applyMatrix4(collider.matrixWorld);
                if (playerBox.intersectsBox(colliderBox)) return false;
            }
            return true;
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(0.05, clock.getDelta());

            if (!modelsLoaded) {
                renderer.render(scene, camera);
                return;
            }

            // Bewegung (schnell!)
            velocity.x = 0;
            velocity.z = 0;
            direction.z = Number(keys['KeyW']) - Number(keys['KeyS']);
            direction.x = Number(keys['KeyD']) - Number(keys['KeyA']);
            direction.normalize();
            if (direction.length() > 0) {
                const moveDir = new THREE.Vector3();
                camera.getWorldDirection(moveDir);
                moveDir.y = 0;
                moveDir.normalize();
                const right = new THREE.Vector3();
                right.crossVectors(moveDir, new THREE.Vector3(0,1,0)).normalize();
                velocity.addScaledVector(moveDir, direction.z * speed * delta);
                velocity.addScaledVector(right, direction.x * speed * delta);
            }

            // Jump & Gravity
            if (keys['Space'] && !isJumping) {
                velocity.y = 8;
                isJumping = true;
            }
            velocity.y -= gravity * delta;
            const newPos = camera.position.clone().add(velocity.clone().multiplyScalar(delta));

            if (newPos.y < 1.6) {
                newPos.y = 1.6;
                velocity.y = 0;
                isJumping = false;
            }

            const testPos = newPos.clone();
            testPos.y = 1.6;
            if (checkCollision(testPos)) {
                camera.position.copy(newPos);
            } else {
                velocity.multiplyScalar(0.7);
            }

            // Kugeln & Hits
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(delta));

                if (bullet.position.length() > 100) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                    continue;
                }

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    enemy.userData.boundingBox.setFromObject(enemy);
                    const bulletSphere = new THREE.Sphere(bullet.position, 0.15);  // Etwas gr√∂√üer f√ºr Hits
                    if (bulletSphere.intersectsBox(enemy.userData.boundingBox)) {
                        scene.remove(enemy);
                        enemies.splice(j, 1);
                        scene.remove(bullet);
                        bullets.splice(i, 1);
                        score++;
                        scoreEl.textContent = score;
                        if (score >= 10) {
                            alert('ü•á LEVEL CLEARED! Bunker gesichert. Neuer Rekord?');
                        }
                        break;
                    }
                }
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
