<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Medal of Honor PS1-Style Demo - Level 1: Bunker mit 3D-Modellen</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: monospace; color: white; background: black; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 10px; left: 10px; z-index: 100;
            font-size: 20px; text-shadow: 2px 2px 4px black;
        }
        #instructions {
            position: absolute; bottom: 10px; left: 10px; z-index: 100;
            font-size: 14px; text-shadow: 1px 1px 2px black;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 24px; height: 24px; z-index: 100;
            pointer-events: none;
            color: lime; font-size: 24px; line-height: 24px; text-align: center;
            text-shadow: 0 0 5px lime;
            font-weight: bold;
        }
        #crosshair::before { content: '+'; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
    <div id="crosshair"></div>
    <div id="ui">
        <div>Kills: <span id="score">0</span>/10</div>
        <div>Level: Bunker Breach</div>
    </div>
    <div id="instructions">
        WASD: Bewegen | Maus: Schauen | Space: Springen | Klick: Schie√üen (Kugeln!)<br>
        Klicke zum Starten (Maus-Sperre)
    </div>
    <script>
        // Szene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x808080, 5, 80);

        // Kamera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 12);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(1);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.BasicShadowMap;
        document.body.appendChild(renderer.domElement);

        // Clock
        const clock = new THREE.Clock();

        // Lichter
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // Texture Loader f√ºr Boden/W√§nde (wie vorher)
        const textureLoader = new THREE.TextureLoader();
        const groundTexture = textureLoader.load('textures/ground.png');
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(20, 20);
        groundTexture.encoding = THREE.sRGBEncoding;
        const wallTexture = textureLoader.load('textures/wall.png');
        wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
        wallTexture.repeat.set(2, 2);

        const groundMaterial = new THREE.MeshLambertMaterial({ map: groundTexture });
        const wallMaterial = new THREE.MeshLambertMaterial({ map: wallTexture });

        // LEVEL (wie vorher)
        const groundGeometry = new THREE.PlaneGeometry(60, 60);
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const walls = [];
        const wallGeometries = {
            long: new THREE.BoxGeometry(30, 6, 1),
            short: new THREE.BoxGeometry(1, 6, 20),
            sandbag: new THREE.BoxGeometry(4, 1.5, 2)
        };
        const wallPositions = [
            { geo: 'long', pos: new THREE.Vector3(0, 3, -20), rot: 0 },
            { geo: 'long', pos: new THREE.Vector3(0, 3, 20), rot: 0 },
            { geo: 'short', pos: new THREE.Vector3(-15, 3, 0), rot: Math.PI / 2 },
            { geo: 'short', pos: new THREE.Vector3(15, 3, 0), rot: Math.PI / 2 },
            { geo: 'sandbag', pos: new THREE.Vector3(-8, 0.75, -10), rot: 0 },
            { geo: 'sandbag', pos: new THREE.Vector3(8, 0.75, -10), rot: 0 },
            { geo: 'sandbag', pos: new THREE.Vector3(0, 0.75, 5), rot: Math.PI / 4 }
        ];

        wallPositions.forEach(wp => {
            const geometry = wallGeometries[wp.geo].clone();
            const wall = new THREE.Mesh(geometry, wallMaterial);
            wall.position.copy(wp.pos);
            wall.rotation.y = wp.rot;
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
            walls.push(wall);
        });
        const colliders = walls;

        // 3D MODELLE f√ºr Gegner
        const gltfLoader = new THREE.GLTFLoader();
        let soldierModel;
        const enemies = [];
        gltfLoader.load('models/soldier.glb', (gltf) => {
            soldierModel = gltf.scene;
            soldierModel.scale.set(1.5, 1.5, 1.5); // Scale f√ºr low-poly Look
            soldierModel.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            // 10 Clones positionieren
            for (let i = 0; i < 10; i++) {
                const enemy = soldierModel.clone();
                enemy.position.set(
                    (Math.random() - 0.5) * 30,
                    0,
                    (Math.random() - 0.5) * 30 - 5
                );
                enemy.rotation.y = Math.random() * Math.PI * 2;
                enemy.userData.boundingBox = new THREE.Box3().setFromObject(enemy);
                scene.add(enemy);
                enemies.push(enemy);
            }
            console.log('Gegner-Modelle geladen!');
        }, undefined, (error) => {
            console.error('Fehler beim Laden des Modells:', error);
            alert('Lade models/soldier.glb herunter! Siehe Anleitung.');
        });

        // Waffe
        const gunGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8);
        const gunMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
        const gun = new THREE.Mesh(gunGeometry, gunMaterial);
        gun.rotation.z = Math.PI / 2;
        gun.position.set(0.4, -0.4, -0.7);
        camera.add(gun);
        scene.add(camera);

        // Physik
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const speed = 50; // **ERH√ñHT: Schnellere Bewegung!**
        let isJumping = false;
        const gravity = 30;
        const playerRadius = 0.6;
        const playerHeight = 1.8;

        // Steuerung
        const keys = {};
        document.addEventListener('keydown', (e) => { keys[e.code] = true; });
        document.addEventListener('keyup', (e) => { keys[e.code] = false; });

        // Pointer Lock
        document.addEventListener('click', () => renderer.domElement.requestPointerLock());
        let euler = new THREE.Euler(0, 0, 0, 'YXZ');
        document.addEventListener('mousemove', (event) => {
            if (document.pointerLockElement === renderer.domElement) {
                euler.setFromQuaternion(camera.quaternion);
                euler.y -= event.movementX * 0.002;
                euler.x -= event.movementY * 0.002;
                euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
                camera.quaternion.setFromEuler(euler);
            }
        });

        // **KUGELN-SCHIESSEN**
        const bullets = [];
        const bulletSpeed = 200;
        document.addEventListener('mousedown', (event) => {
            if (event.button === 0 && document.pointerLockElement) {
                // Kugel erstellen
                const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                bullet.position.copy(camera.position);
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(camera.quaternion);
                bullet.userData.velocity = forward.multiplyScalar(bulletSpeed);
                scene.add(bullet);
                bullets.push(bullet);
            }
        });

        let score = 0;
        const scoreEl = document.getElementById('score');

        // Kollision Player
        function checkCollision(newPos) {
            const playerBox = new THREE.Box3().setFromCenterAndSize(newPos, new THREE.Vector3(playerRadius*2, playerHeight, playerRadius*2));
            for (let collider of colliders) {
                const colliderBox = collider.geometry.boundingBox.clone();
                colliderBox.applyMatrix4(collider.matrixWorld);
                if (playerBox.intersectsBox(colliderBox)) return false;
            }
            return true;
        }

        // Animate
        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(0.05, clock.getDelta());

            // Bewegung
            velocity.x = 0;
            velocity.z = 0;
            direction.z = Number(keys['KeyW']) - Number(keys['KeyS']);
            direction.x = Number(keys['KeyD']) - Number(keys['KeyA']);
            direction.normalize();
            if (direction.length() > 0) {
                const moveDir = new THREE.Vector3();
                camera.getWorldDirection(moveDir);
                moveDir.y = 0;
                moveDir.normalize();
                const right = new THREE.Vector3();
                right.crossVectors(moveDir, new THREE.Vector3(0,1,0)).normalize();
                velocity.addScaledVector(moveDir, direction.z * speed * delta);
                velocity.addScaledVector(right, direction.x * speed * delta);
            }

            // Jump & Gravity
            if (keys['Space'] && !isJumping) {
                velocity.y = 8;
                isJumping = true;
            }
            velocity.y -= gravity * delta;
            const newPos = camera.position.clone().add(velocity.clone().multiplyScalar(delta));

            // Y-Kollision
            if (newPos.y < 1.6) {
                newPos.y = 1.6;
                velocity.y = 0;
                isJumping = false;
            }

            // XZ-Kollision
            const testPos = newPos.clone();
            testPos.y = 1.6;
            if (checkCollision(testPos)) {
                camera.position.copy(newPos);
            } else {
                velocity.multiplyScalar(0.7);
            }

            // **KUGELN UPDATE & KOLLISIONEN**
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(delta));

                // Out of bounds?
                if (bullet.position.length() > 100) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                    continue;
                }

                // Check hit enemies
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (!enemy.userData.boundingBox) continue; // Noch nicht geladen
                    enemy.userData.boundingBox.setFromObject(enemy); // Update
                    const bulletSphere = new THREE.Sphere(bullet.position, 0.1);
                    if (bulletSphere.intersectsBox(enemy.userData.boundingBox)) {
                        // Hit!
                        scene.remove(enemy);
                        enemies.splice(j, 1);
                        scene.remove(bullet);
                        bullets.splice(i, 1);
                        score++;
                        scoreEl.textContent = score;
                        console.log('Hit! Kills:', score);
                        if (score >= 10) {
                            alert('Level Cleared! Bunker gesichert. üèÜ');
                        }
                        break;
                    }
                }
            }

            renderer.render(scene, camera);
        }
        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
