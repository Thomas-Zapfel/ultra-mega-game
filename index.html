<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Medal of Honor PS1-Style Demo mit Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <script>
        // Szene aufbauen
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x808080); // Grauer Himmel für Retro-Look
        scene.fog = new THREE.Fog(0x808080, 10, 100); // Nebel für PS1-Ästhetik

        // Kamera (FPS-Perspektive)
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 0); // Augenhöhe

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: false }); // Kein Antialiasing für Pixel-Look
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(1); // Niedrige Auflösung für Retro
        document.body.appendChild(renderer.domElement);

        // Licht
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        // Boden (einfache Ebene wie in MoH-Levels)
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x556B2F }); // Olivgrün für WWII-Boden
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // Wände/Hindernisse (einfache Boxen als "Bunker")
        const wallGeometry = new THREE.BoxGeometry(5, 5, 1);
        const wallMaterial = new THREE.MeshBasicMaterial({ color: 0xA0522D }); // Braun für Sandbags
        for (let i = 0; i < 5; i++) {
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.set(Math.random() * 50 - 25, 2.5, Math.random() * 50 - 25);
            scene.add(wall);
        }

        // Gegner (einfache rote Boxen als "Nazis" – retro-stylisiert)
        const enemies = [];
        const enemyGeometry = new THREE.BoxGeometry(1, 2, 1);
        const enemyMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        for (let i = 0; i < 5; i++) {
            const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            enemy.position.set(Math.random() * 40 - 20, 1, Math.random() * 40 - 20);
            scene.add(enemy);
            enemies.push(enemy);
        }

        // Waffe (einfache Linie als "Gewehr" – attached an Kamera)
        const gunGeometry = new THREE.BoxGeometry(0.2, 0.2, 1);
        const gunMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const gun = new THREE.Mesh(gunGeometry, gunMaterial);
        gun.position.set(0.5, -0.5, -1); // Vor der Kamera
        camera.add(gun);

        // Steuerungsvariablen
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const speed = 0.1;

        // Maus-Lock für FPS
        document.addEventListener('click', () => {
            renderer.domElement.requestPointerLock();
        });

        // Maus-Bewegung
        let mouseX = 0, mouseY = 0;
        document.addEventListener('mousemove', (event) => {
            if (document.pointerLockElement === renderer.domElement) {
                mouseX = event.movementX * 0.002;
                mouseY = event.movementY * 0.002;
            }
        });

        // Tastatur-Events
        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'w': moveForward = true; break;
                case 's': moveBackward = true; break;
                case 'a': moveLeft = true; break;
                case 'd': moveRight = true; break;
            }
        });
        document.addEventListener('keyup', (event) => {
            switch (event.key) {
                case 'w': moveForward = false; break;
                case 's': moveBackward = false; break;
                case 'a': moveLeft = false; break;
                case 'd': moveRight = false; break;
            }
        });

        // Schießen (Linksklick)
        document.addEventListener('mousedown', (event) => {
            if (event.button === 0 && document.pointerLockElement === renderer.domElement) {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera); // Zentrum des Bildschirms
                const intersects = raycaster.intersectObjects(enemies);
                if (intersects.length > 0) {
                    const hitEnemy = intersects[0].object;
                    scene.remove(hitEnemy);
                    enemies.splice(enemies.indexOf(hitEnemy), 1);
                    console.log('Gegner getroffen!'); // Simuliere Treffer
                }
            }
        });

        // Kollisions-Check (einfach, gegen Wände)
        function checkCollision(newPosition) {
            // Einfache Box-Check – erweitern für bessere Physik
            return true; // Für Demo immer erlauben; füge echte Checks hinzu
        }

        // Animations-Loop
        function animate() {
            requestAnimationFrame(animate);

            // Rotation mit Maus
            camera.rotation.y -= mouseX;
            camera.rotation.x -= mouseY;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            mouseX = mouseY = 0;

            // Bewegung
            velocity.x -= velocity.x * 0.1; // Reibung
            velocity.z -= velocity.z * 0.1;
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveLeft) - Number(moveRight);
            direction.normalize();

            if (moveForward || moveBackward) velocity.z -= direction.z * speed;
            if (moveLeft || moveRight) velocity.x -= direction.x * speed;

            const newPosition = camera.position.clone().add(velocity);
            if (checkCollision(newPosition)) {
                camera.position.copy(newPosition);
            }

            renderer.render(scene, camera);
        }

        animate();

        // Resize-Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
